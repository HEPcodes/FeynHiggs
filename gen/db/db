#! /bin/sh -x

math -run me=\"`basename $0`\" -run debug=${DEBUG:-0} << \_EOF_
AppendTo[$Echo, "stdout"];

<< FeynArts`

<< FormCalc`

(*Sq[Mfy[a__]] = Mfy2[a];*)

Format[Mino3, FortranForm] := "M_3";
Format[Mino3C, FortranForm] := "M_3C";

NClear[];

SetOptions[InsertFields,
  InsertionLevel -> {Classes},
  ExcludeParticles -> {V, S[4], S[6], S[1], S[2], S[3], S[5]},
  Model -> (*FVMSSM*) MSSMQCD];
(* MSSMQCD because we must have only the TB-enhanced terms *)

SetOptions[Paint,
  PaintLevel -> Flatten[{InsertionLevel} /. Options[InsertFields]],
  ColumnsXRows -> {3, 4}];

SetOptions[CalcFeynAmp,
  Dimension -> 4];

SetOptions[PrepareExpr,
  Optimize -> True,
  Expensive -> {_B0q, _B1q},
  FinalTouch -> simp];

SetOptions[WriteExpr,
  RealArgs -> {B0q, B1q},
  IndexType -> "integer"];


InitializeModel[Model /. Options[InsertFields]];

If[ debug === 1, MkDir[$PaintSE = "d/"] ];


se[a__, q_] := SelfEnergy[a] /. {
  B0i[bb0, args__] -> B0q[args, q],
  B0i[bb1, args__] -> B1q[args, q] };

se[proc:(F[t_, {g1_}] -> F[t_, {g2_}]), p_] :=
  asdb/Alfas se[proc, p, LastSelections -> F[15], Qqcd] +
  adb/Alfa se[proc, p, LastSelections -> F[12], Qew] +
  AlfaGF/Alfa se[proc, p, LastSelections -> F[11], Qew]

Mcorr[t_, g1_, g2_] := 
Block[ {m1 = TheMass[F[t, {g1}]], m2 = TheMass[F[t, {g2}]]},
  {(*IndexDelta[g1, g2] m1 +*) LScalarCoeff[#],
    1/2 LVectorCoeff[#], 1/2 RVectorCoeff[#]}& @
    -se[F[t, {g1}] -> F[t, {g2}], 0 (*Sqrt[p2]*)]
];

N[sqrt2] = Sqrt[2.];

IDelta/: IDelta[i_, j_] a_ := IDelta[i, j] (a /. j -> i) /; !FreeQ[a, j];

Delta[i_, i_] = 1;

simp[x_] := FullSimplify[x /. Delta -> IDelta /. IDelta -> Delta];


write[t_, tag_] :=
Block[ {expr, hh},
  expr = Mcorr[t, g1, g2] /.
    IndexDelta -> IDelta /. IDelta -> Delta;

  If[ debug === 1, Put[expr, ToFileName[MkDir["m"], tag <> ".m"]] ];

  expr = expr /.
    { Sqrt[2] -> sqrt2, 1/Sqrt[2] -> 1/sqrt2,
      (*Alfas -> als, Alfa -> al,*)
      MCha -> MChaL, MCha2 -> (MChaL[##]^2 &),
      UCha -> UChaL, UChaC -> UChaLC,
      VCha -> VChaL, VChaC -> VChaLC,
      MNeu -> MNeuL, MNeu2 -> (MNeuL[##]^2 &),
      ZNeu -> ZNeuL, ZNeuC -> ZNeuLC,
      Mf[3,g_] -> Mf[tT,g],
      Mf2[3,g_] -> Mf2[tT,g],
      MSf[s_,3,g__] -> MSf[s,tT,g],
      MSf2[s_,3,g__] -> MSf2[s,tT,g],
      USf[s1_,s2_,3,g__] -> USf[s1,s2,tT,g],
      USfC[s1_,s2_,3,g__] -> USfC[s1,s2,tT,g],
      Mf[4,g_] -> Mf[bTR,g],
      Mf2[4,g_] -> Mf2[bTR,g],
      MSf[s_,4,g__] -> MSdL[s,g],
      MSf2[s_,4,g__] -> MSdL2[s,g],
      USf[s1_,s2_,4,g__] -> USdL[s1,s2,g],
      USfC[s1_,s2_,4,g__] -> USdLC[s1,s2,g]
    } /. ToOldBRules;

  hh = OpenFortran[ToFileName[MkDir["f"], tag <> ".F"]];
  WriteString[hh, "\
* " <> tag <> ".F\n\
* mass-matrix corrections\n\
* generated by " <> me <> " " <> TimeStamp[] <> "\n\
* this file is part of FeynHiggs\n\n\
#include \"externals.h\"\n\
#include \"types.h\"\n\n\n\
\tsubroutine " <> tag <> "(se, g1, g2, Qqcd, asdb, Qew, adb)\n\
\timplicit none\n\
\tComplexType se(3)\n\
\tinteger g1, g2\n\
\tRealType Qqcd, asdb, Qew, adb\n\n\
#include \"FH.h\"\n\
#include \"looptools.h\"\n\n"];
  WriteExpr[hh, {
    se[1] -> expr[[1]],
    se[2] -> expr[[2]],
    se[3] -> expr[[3]]}
  ];
  WriteString[hh, "\tend\n"];
  Close[hh]
];


(*write[3, "MUcorr"];*)
write[4, "MDcorr"];
_EOF_


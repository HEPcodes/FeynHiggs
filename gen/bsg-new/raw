#! /bin/bash -x

[[ "$*" =~ (bsgamma|bsglu)[\ -](Hp|Cha|Neu|Glu|SM) ]] || {
  cat << _EOF_
Usage:  $0 bsgamma|bsglu Hp|Cha|Neu|Glu|SM
will output diagrams if DEBUG=1
_EOF_
  exit 1
}

proc="${BASH_REMATCH[1]}"
tag="${BASH_REMATCH[2]}"
out="m/$proc-$tag"
args="proc=\"$proc\"; tag=\"$tag\"; out=\"$out\"; debug=${DEBUG:-0}"

shopt -s nullglob
test -d m || mkdir m
rm -f "$out".*

### STEP 1: GENERATE B -> S GAMMA AMPLITUDES

math -run "$args" << \_EOF_ > "$out.log"
AppendTo[$Echo, "stdout"];

<< FeynArts`

$ShapeDataDir = "./ShapeData";

<< FormCalc`

MD = MD2 = Mdy[1] = 0;
MS = MS2 = Mdy[2] = 0;
MU = MU2 = 0;
MC = MC2 = 0;
MT = MTr;
MT2 = MTr2;
Sq[MTr] = MTr2;

Sq[Alfas] =.;
Alfas = asMW;

(*_USf = VCha = UCha = IndexDelta;*)

If[ debug === 1, paint = Paint; put = Put ];

vec["bsgamma"] = V[1];
vec["bsglu"] = V[5];

opt["Hp"] = LastSelections -> S[5];
opt["Cha"] = LastSelections -> F[12];
opt["Neu"] = LastSelections -> F[11];
opt["Glu"] = LastSelections -> F[15];
opt["SM"] = ExcludeParticles -> {F[11|12|15],S[5]};

tops = CreateTopologies[1, 1 -> 2];

ins = InsertFields[tops,
  F[4,{3}] -> {F[4,{2}], vec[proc]},
  InsertionLevel -> {Classes},
  opt[tag],
  Model -> myMSSMQCD];

paint[ins,
  ColumnsXRows -> {3, 4},
  DisplayFunction -> (Export[out <> ".ps", #, ImageSize -> 72 2 {3, 4}]&)];

amp = CreateFeynAmp[ins];

put[amp, out <> ".amp"];

vert = CalcFeynAmp[amp,
  MomElim -> 2,
  FermionChains -> Chiral,
  FermionOrder -> None];

put[vert, out <> ".vert"];

abbr = Join[
  Abbr[] /. DiracChain[s2_Spinor, om_, mu_, s1:Spinor[p1_, m1_, _]] :>
    1/m1 (I/2 DiracChain[sigmunu[om]] +
          2 Pair[mu, p1] DiracChain[s2, om, s1]),
  Subexpr[] ];

put[abbr, out <> ".abbr"];

mat[p_Plus] := mat/@ p;

mat[t_Times] := DeleteCases[t, _DiracChain | _SUNT] *
  mat@@ Cases[t, _DiracChain | _SUNT];

mat[DiracChain[sigmunu[om_]], SUNT[Col1, Col2]] :=
  Mat[O7[om]]/(EL MB/(16 Pi^2));

mat[DiracChain[sigmunu[om_]], SUNT[Glu3, Col2, Col1]] :=
  Mat[O8[om]]/(GS MB/(16 Pi^2));

coeff = Plus@@ (vert /. ToOldBRules) //. abbr /.
  Mat[p_] :> mat[Expand[p]] /.
  Den[p_, m_] :> 1/(p - m) /.
  SUNT -> sunt;

put[coeff, out <> ".coeff"];

Lagpre = 4 GF/Sqrt[2] ckm[3][3,2];

CKM/: CKM[i_, j_] CKMC[i_, k_] := ckm[i][j,k];

ckm[1][i__] := -ckm[2][i] - ckm[3][i];

FeynCalcPut[
  Collect[coeff/Lagpre, _mat | _Mat, Simplify],
  out <> ".fc"]
_EOF_


### STEP 2: REDUCE & CANONICALLY ORDER THE TENSOR INTEGRALS

math -run "$args" << \_EOF_ >> "$out.log"
AppendTo[$Echo, "stdout"];

<< FeynCalc`

test = Get[out <> ".fc"];

pave = Cases[test, _PaVe, Infinity] //Union;

pave = Thread[pave -> PaVeReduce[pave]];

test = PaVeOrder[test /. pave];

Put[test, out <> ".fc.red"]
_EOF_


### STEP 3: SIMPLIFY

math -run "$args" << \_EOF_ >> "$out.log"
AppendTo[$Echo, "stdout"];

<< FormCalc`

<< FormCalc`tools`btensor`

Mdy[g_] := Mf[bTR,g];
MSf[s_,4,g_] := MSf[s,bTR,g];
MSf2[s_,4,g_] := MSf2[s,bTR,g];
USf[s__,4,g_] := USf[s,bTR,g];
USfC[s__,4,g_] := USfC[s,bTR,g];
MASf[as_,4] := MASf[as,bTR];
MASf2[as_,4] := MASf2[as,bTR];
UASf[as__,4] := UASf[as,bTR];
UASfC[as__,4] := UASfC[as,bTR];
Kf[g__,4] := Kf[g,bTR];
KfC[g__,4] := KfC[g,bTR];

Sq[MTr] = MTr2;

ckmtest[SumOver[g_, 3] ckm[g_][i_, j_] r_] := 0 /; FreeQ[r, g];

ckmtest[other_] = other;


test = FeynCalcGet[out <> ".fc.red"];

zero = ckmtest[Simplify[test /. _Mat -> 0]]

If[ zero =!= 0,
  Print["WARNING: REMAINDER NOT ZERO"];
  Put[zero, out <> ".ZERO"] ];


Alfa = Sqrt[2]/Pi GF MW2 SW2;
ckm[i_][j_, k_] := CKM[i, j] CKMC[i, k];

test = Collect[test /. _mat -> 0, _SumOver, simp];

(*Put[test, out <> ".pre"];*)

test = test /. simp -> FullSimplify;

Put[test, out <> ".full"];

coeff = {
  ToSymbol[C7L, tag] -> SplitSums[Coefficient[test, Mat[O7[6]]]/I],
  ToSymbol[C8L, tag] -> SplitSums[Coefficient[test, Mat[O8[6]]]/I],
  ToSymbol[C7R, tag] -> SplitSums[Coefficient[test, Mat[O7[7]]]/I],
  ToSymbol[C8R, tag] -> SplitSums[Coefficient[test, Mat[O8[7]]]/I] };

coeff = DeleteCases[coeff, _ -> {0}];

Put[coeff, out <> ".m"];
_EOF_

gzip "$out.ps"* "$out.log"

test -f "$out.m"


* Resum4Hb.F
* resums the 4H coupling taking into account four scales:
*   low scale = MT
*   medium scale 1 = MCha
*   medium scale 2 = MGlu
*   high scale = MSUSY
* this file is part of FeynHiggs
* last modified 29 Jan 16 th

#include "externals.h"
#include "types.h"


* Main function calculating the correction to Mh due to resummation

	subroutine Resum4Hb(dPhi22, rMUE, XtOS)
	implicit none
	RealType dPhi22, rMUE, XtOS

#include "Resum4Hb.h"
#define __SUBROUTINE__ "Resum4Hb"

	integer fail
	RealType x(nSM:nSplit)
	RealType MSUSYOS2, MSUSYOS, MSUSYMS, htMT2, llog
	RealType mueOS, mueMS, mueMS2
	RealType YtOS, XtMS, xOS, xMS
	RealType g1uC, g1dC, g1udC, g2uC, g2dC, g2udC, htC, lC
	RealType subnonlog, sublog2L, sublog1L
	external threshdiff

	RealType ggyMT2
	parameter (ggyMT2 = 1/24D0*gMT2*gyMT2*
     &    (gyMT2 - 25*gMT2)/(gMT2 + gyMT2)**2)

	htMT2 = htMT**2

	tTop = log(MTy2)
	tCha = log(MCha(1)*MCha(2))
	tGlu = log(MGl2)
	MSUSYOS2 = MSf(1,3,3)*MSf(2,3,3)
	MSUSYOS = sqrt(MSUSYOS2)
	tSUSY = log(MSUSYOS2)
	if( tCha .gt. tSUSY ) then
	  Warning("Resum4H: MCha > MSUSY, setting MCha = MSUSY")
	  tCha = tSUSY
	endif
	if( MA02 .lt. 1D-4*MSUSYOS2 ) Warning("Resum4H: MA << MSUSY")
	if( MSUSYOS2 .lt. 1D-4*MA02 ) Warning("Resum4H: MSUSY << MA")

	xOS = XtOS/MSUSYOS
	mueOS = rMUE/MSUSYOS
	yOS = xOS + mueOS*(1/TB + TB)
	llog = tSUSY - tTop

	if( looplevel .eq. 4 ) then
	  xMS = xOS*(1 + cL*(4*g3MT2 -
     &      llog*(ggyMT2 + .75D0*htMT2*(1 - xOS)*(1 + xOS))))
	  mueMS = mueOS
	else
	  call rgeloopfun(lf, mueOS)
	  if( abs(xOS) .gt. 1 ) then
	    xMS = 4/3D0*g3MT2*(8 + (5 + 3*llog - xOS)*xOS) -
     &        ggyMT2*llog*xOS -
     &        1/24D0*htMT2/SB2*(
     &          (18*(2*lf(4) - mueOS**2*lf(2) - 3) +
     &            (18*llog - 105)*SB2)*xOS -
     &          24*(6 - pi*sqrt3)*CB2*yOS +
     &          4*xOS*(
     &            (6*log2 + 9*log(abs(XtOS)*MTy/MSUSYOS2))*SB2*xOS**2 +
     &            (9 - 2*pi*sqrt3)*CB2*yOS**2 )
     &        )
	  else
	    xMS = 32/3D0*g3MT2 + (6 - pi*sqrt3)*htMT2*yOS/TB2
	  endif
	  msMS = (1 + cL*(-16/3D0*g3MT2 +
     &      .75D0*htMT2*(lf(5) + CB2 +
     &        (2*SB2*xOS**2 - (pi/sqrt2 - 2)*CB2*yOS**2))/SB2))
	  xMS = (xOS + cL*xMS)/msMS
	  mueMS = mueOS/msMS
	endif
	xMS = XtMS/MSUSYMS
	xMS2 = xMS**2

* initial values from tree-level relations
	x(ilam) = .15D0
	x(ig1u) = gyMT*SB
	x(ig1d) = gyMT*CB
	x(ig2u) = gMT*SB
	x(ig2d) = gMT*CB

* solve for x using Newton procedure
	call FindMinimum(fail, threshdiff, x(ilam), nSplit - nSM + 1)

#include "FOSubtract.h"

* calc Mh^RGE, combine with subtraction terms
	dPhi22 = (vev**2*x(ilam) - subnonlog - sublog2L - sublog1L)/SB2

	if( debuglevel .gt. 4 ) then
	  DHIGGS "final values:"
	  DHIGGS "lam(MT)   =", x(ilam)		ENDL
	  DHIGGS "subnonlog =", subnonlog	ENDL
	  DHIGGS "sublog2L  =", sublog2L	ENDL
	  DHIGGS "sublog1L  =", sublog1L	ENDL
	  DHIGGS "dPhi22    =", dPhi22		ENDL
	endif
	end


************************************************************************
* threshdiff is the function which is minimized by FindMinimum.
* It takes n=5 input parameters (the guesses for lambda(MT) and
* the gaugino-gaugino-higgs couplings g[12][ud](MCha)) and uses
* them to run all couplings up to Q = MSUSY.
* At Q = MSUSY it checks how well the threshold corrections are
* fulfilled and saves the discrepancies in diff(1..5).
* |diff|^2 is given back to FindMinimum.

	subroutine threshdiff(n, x, dx, dxmin)
	implicit none
	integer n
	RealType x(nSM:nSplit), dx(nSM:nSplit), dxmin

#include "Resum4Hb.h"

	RealType y(nSplit)
	RealType yg1ud, yg2ud, y13
	RealType ySB, ySB2, yCB, yCB2, yTB1, yggy, dx2

	external betaSM2L, betaSplit2L

* known values at Q = MT
	y(ig) = gMT
	y(ig3) = g3MT
	y(igy) = gyMT
	y(iht) = htMT
	y(itb) = TB

	y(ilam) = x(ilam)

* run from Q = MT to Q = MCha with SM RGEs
	call ODESolve(nSM, betaSM2L, y,
     &    tTop, tCha, odeeps, odeh1, 0)

	y(ig1d) = x(ig1d)
	y(ig1u) = x(ig1u)
	y(ig2d) = x(ig2d)
	y(ig2u) = x(ig2u)

* threshold conditions @ MCha
	yg1ud = y(ig1d) + y(ig1u)
	yg2ud = y(ig2d) + y(ig2u)
	y13 = yg1ud**2 + 3*yg2ud**2

	y(iht) = y(iht)*(1 - cL/12D0*y13)

	y(ilam) = (y(ilam) + cL/12D0*(
     &    (yg1ud - yg2ud)*(yg1ud + yg2ud)*
     &      (y13 + 6*(y(ig1d)**2 + y(ig1u)**2)) +
     &    6*yg2ud*(
     &      yg2ud*(yg1ud**2 + 5*(y(ig2d)**2 + y(ig2u)**2)) +
     &      2*(y(ig1d)**2*y(ig2d) + y(ig1u)**2*y(ig2u)) )
     &  ))/(1 + cL/3D0*y13)

* run from Q = MCha to Q = MSUSY with Split RGEs
	call ODESolve(nSplit, betaSplit2L, y,
     &    tCha, tSUSY, odeeps, odeh1, 0)

* threshold conditions @ MSUSY
	yCB2 = 1/(1 + y(itb)**2)
	yCB = sqrt(yCB2)
	ySB = y(itb)*yCB
	ySB2 = ySB**2
	yTB1 = yCB2*(1 - y(itb))*(1 + y(itb))
	yggy = y(ig)**2 + y(igy)**2

	dx(ilam) = y(ilam) - .25D0*(yggy*yTB1**2 - cL*(
     &    2/3D0*y(ig)**4*(3 - yTB1**2) +
     &    yggy**2*(1 + 12*yCB2**2*y(itb)**2*yTB1**2) +
     &    y(iht)**2*xMS2*(2*y(iht)**2*(xMS2 - 12) +
     &      yggy*yTB1*(yTB1 - 3))))
	if( looplevel .gt. 3 ) then
	  call rgeloopfun(lf, mueMS)
<<<
	dx(ilam) = dx(ilam) - 8/3D0*cL**2*y(iht)**4*y(ig3)**2*
     &    xMS*(-12-6*xMS+14*xMS2+.5D0*xMS**3-xMS2**2) -
     &    (3*cL**2*(0.5D0 + 6*mueMS2 - (13*yCB2)/2D0 + yCB2*pi**2 
     &    + 60*Kfac*yCB2 - 4*(3 + 16*Kfac)*xMS*yCB*(xMS*yCB 
     &    + mueMS/ySB) + 4*(1 + 4*Kfac)*xMS**3*yCB*(xMS*yCB 
     &    + mueMS/ySB)  
     &    - (3 + 16*Kfac)*(xMS*yCB + mueMS/ySB)**2 
     &    - (xMS2**3*ySB2)/2D0 
     &    - 8*lfr1 - 2*mueMS2*lfr1 + 3*mueMS2*lfr2  
     &    + xMS2*(-7 - 6*mueMS2 + 15*yCB2 - 24*Kfac*yCB2 + (2*(7 + 
     &    36*Kfac)
     &    * (xMS*yCB + mueMS/ySB)**2)/3D0 + 4*lfr1 - 6*mueMS2*lfr1 
     &    - 4*lfr2 
     &    - 6*mueMS2*lfr2) + (xMS2**2*(22 + 4*mueMS2 - 25*yCB2 - ((19 
     &    + 96*Kfac)
     &    * (xMS*yCB + mueMS/ySB)**2)/3D0 - 2*lfr1 + 4*mueMS2*lfr1 
     &    + 2*lfr2 
     &    + 2*mueMS2*lfr2))/4D0 + 4*lfr3)*y(iht)**6)/ySB2
	endif
	dx2 = dx(ilam)**2

	dx(ig1d) = y(ig1d) - y(igy)*yCB*(1 + cL*
     &    ((7/16D0*ySB2 - 11/4D0)*y(igy)**2 + 
     &     (21/16D0*ySB2 - 3/8D0)*y(ig)**2))
	dx2 = dx2 + dx(ig1d)**2

	dx(ig2d) = y(ig2d) - y(ig)*yCB*(1 + cL*
     &    ((7/16D0*ySB2 - 1/8D0)*y(igy)**2 -
     &     (11/16D0*ySB2 + 2/3D0)*y(ig)**2))
	dx2 = dx2 + dx(ig2d)**2

	dx(ig1u) = y(ig1u) - y(igy)*ySB*(1 + cL*
     &    ((7/16D0*yCB2 - 11/4D0)*y(igy)**2 + 
     &     (21/16D0*yCB2 - 3/8D0)*y(ig)**2 +
     &     (3/2D0*y(iht)/ySB)**2))
	dx2 = dx2 + dx(ig1u)**2

	dx(ig2u) = y(ig2u) - y(ig)*ySB*(1 + cL*
     &    ((7/16D0*yCB2 - 1/8D0)*y(igy)**2 -
     &     (11/16D0*yCB2 + 2/3D0)*y(ig)**2 +
     &     (3/2D0*y(iht)/ySB)**2))
	dx2 = dx2 + dx(ig2u)**2

	dxmin = dx2
	end

